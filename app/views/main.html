
	<navbar></navbar>
	<ed-system-map></ed-system-map>
	<system-info></system-info>
	<color-selection></color-selection>
	<footer></footer>
	<script type="x-shader/x-vertex" id="vertexshader">
			attribute vec4 aColorIndex;
			attribute float aSize;

			uniform float scale;
			uniform int activeColoring;

			varying float vActiveColorIndex;

			void main() {
				//TODO: solve this with a preprocessor directive instead and just recompile the shader when activeColoring changes
				if (activeColoring == 0)
					vActiveColorIndex = float(aColorIndex[0]);
				else if (activeColoring == 1)
					vActiveColorIndex = float(aColorIndex[1]);
				else if (activeColoring == 2)
					vActiveColorIndex = float(aColorIndex[2]);
				else
					vActiveColorIndex = float(aColorIndex[3]);

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = min(aSize * ( scale / length( mvPosition.xyz ) ), 40.0);
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform sampler2D texture;
			uniform sampler2D colorPalette; //width: 16, height: 2

			varying float vActiveColorIndex;

			void main() {
				gl_FragColor = texture2D( colorPalette, vec2( vActiveColorIndex / 16.0, 0.0 ) );
				gl_FragColor.a *= texture2D( texture, gl_PointCoord ).a;
				if (gl_FragColor.w < 0.9) discard;
			}
		</script>







		<script type="x-shader/x-vertex" id="dotVertexShader">
				/**
				* Example Vertex Shader
				* Sets the position of the vertex by setting gl_Position
				*/

				// Set the precision for data types used in this shader
				precision highp float;
				precision highp int;

				uniform float time;

				attribute vec2 uv2;

				// Examples of variables passed from vertex to fragment shader
				varying vec3 vPosition;
				varying vec3 vNormal;
				varying vec2 vUv;
				varying vec2 vUv2;

				void main() {

				    // To pass variables to the fragment shader, you assign them here in the
				    // main function. Traditionally you name the varying with vAttributeName
				    vNormal = normal;
				    vUv = uv;
				    vUv2 = uv2;
				    vPosition = position;

				    // This sets the position of the vertex in 3d space. The correct math is
				    // provided below to take into account camera and object data.
				    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
		</script>

		<script type="x-shader/x-fragment" id="dotFragmentShader">
				precision highp float;

				#define pi 3.1415926536
				#define N 12

				varying vec2 vUv;
				uniform float time;
				uniform float speed;
				uniform vec2 uvScale;
				uniform float brightness;
				uniform vec3 color;
				uniform float popSize;
				uniform float baseSize;
				uniform float radius;

				void main(void) {
				    vec2 position = ( vUv.xy - 0.5 ) * uvScale;
				    vec2 center = position;

				    float c = 0.;
				    float o;
				    for (int i = 0; i < N; i++)  {
				        vec2 xy;
				        o = float(i) / float(N) * 2.0 * pi;
				        xy.x = radius * cos(o);
				        xy.y = radius * sin(o);
				        xy += center;
				        c += brightness * pow(200000.0, (baseSize - length(xy) * 1.9) * (0.99 + popSize * fract(float(-i) / float(N) - time * speed))) / 20000.0;
				    }
				    gl_FragColor = vec4(
				        clamp( c * color, vec3( 0.0 ), vec3( 1.0 ) ),
				        1.0
				    );
				}
		</script>
